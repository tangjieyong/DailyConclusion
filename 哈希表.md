在链表和树结构中执行查询操作本质上都是将要查询的值与链表或数据结构中的每个值进行对比，在链表中这样的操作复杂度是O(n),在树中这种操作的复杂度是O(logn),如何让查询的时间复杂度降到O(1)左右呢，使用哈希表，可以把哈希表理解为将元素存放在多个查找表中（链表，树）

哈希表又被称为散列表，本质上是通过在数组上挂载查找表来实现的，根据不同的需求可以在数组的每一个索引上挂载链表或者树

在哈希表中，添加进入的键通过哈希函数转化为对应的数组索引，很难保证一个键通过哈希函数的转换可以对应不同的索引，因为数组的容量是有限的，不可能待添加多少个键就创建多大的数组，因此如果数组的长度是一个限定的值，那么向哈希表中不断地添加元素就会产生一个索引存放多个数据，这就是哈希冲突，对于哈希冲突，可以在每个索引处创建一个查找表，产生冲突的数据可以堆放在对应的查找表中

哈希表体现的是空间换时间的思想，所达到的是空间和时间的平衡，因此哈希函数的设计很重要，让键通过哈希函数的计算分布的越均匀越好

哈希函数的一个简单的设计思路是让存入的键模一个素数

哈希表实现的前提是将传入的键转化为数值，只有当传入的键转化为数值后才能将其模一个素数，获得其对应的数组索引，如何将键转化为数值，可以直接使用Java提供的hashcode方法

